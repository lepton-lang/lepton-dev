def Eq(A: 'Type, a b: A): 'Type = ∀(P: A -> 'Type) -> P(a) -> P(b)

def refl(A: 'Type, a: A): A.Eq(a, a) = {
    (P: A -> 'Type, pa: P(a)) => pa
}

def symmetry(A: 'Type, a b: A, eqab: A.Eq(a, b)): A.Eq(b, a) = {
    eqab((b': A) => A.Eq(b', a), A.refl(a))
}

type ℕ = inductive {
    Zero
    Succ(ℕ)
}

def (+)(a b : ℕ): ℕ = match a {
    case ℕ::Zero => b
    case ℕ::Succ(a') => ℕ::Succ(a' + b)
}

def induction(
    P: ℕ -> 'Type,
    base: P(ℕ::Zero),
    induce: ∀(n: ℕ) -> P(n) -> P(ℕ::Succ(n)),
    nat: ℕ,
): P(nat) = match nat {
    case ℕ::Zero => base
    case ℕ::Succ(n') => induce(n', induction(P, base, induce, n'))
}

def inductionReduce(
    a b: ℕ,
    eqba: Eq(ℕ, b, a),
    P: ℕ -> 'Type,
    pa: P(a),
): P(b) = {
    let eqab = ℕ.symmetry(b, a, eqba)
    eqab(P, pa)
}

def theoremPlusZero: ∀(n: ℕ) -> ℕ.Eq(n + ℕ::Zero, n) = {
    ((n': ℕ) => ℕ.Eq(n' + ℕ::Zero, n')).induction(
        ℕ.refl(ℕ::Zero),
        (n': ℕ, assumption: ℕ.Eq(n' + ℕ::Zero, n')) => {
            inductionReduce(
                n', n' + ℕ::Zero, assumption,
                (n'': ℕ) => ℕ.Eq(ℕ::Succ(n''), ℕ::Succ(n')),
                ℕ.refl(ℕ::Succ(n'))
            )
        }
    )
}
