def Eq(A: 'Type, a b: A): 'Type = ∀(P: A -> 'Type) -> P(a) -> P(b)

def refl(A: 'Type, a: A): A.Eq(a, a) = {
    (P: A -> 'Type, pa: P(a)) => pa
}

def symmetry(A: 'Type, a b: A, eqab: A.Eq(a, b)): A.Eq(b, a) = {
    eqab((b': A) => A.Eq(b', a), A.refl(a))
}

type ℕ = inductive {
    Zero
    Succ(ℕ)
}

def o: ℕ = ℕ::Zero
def succ(n: ℕ): ℕ = ℕ::Succ(n)

operator binary (===) left-assoc {
    looser-than (+)
}

def (===)(a b: ℕ): 'Type = ℕ.Eq(a, b)

def (+)(a b : ℕ): ℕ = match a {
    case ℕ::Zero => b
    case ℕ::Succ(a') => ℕ::Succ(a' + b)
}

def induction(
    P: ℕ -> 'Type,
    base: P(ℕ::Zero),
    induce: ∀(n: ℕ) -> P(n) -> P(n.succ),
    nat: ℕ,
): P(nat) = match nat {
    case ℕ::Zero => base
    case ℕ::Succ(n') => induce(n', P.induction(base, induce, n'))
}

def inductionReduce(
    a b: ℕ,
    eqba: Eq(ℕ, b, a),
    P: ℕ -> 'Type,
    pa: P(a),
): P(b) = {
    let eqab = ℕ.symmetry(b, a, eqba)
    eqab(P, pa)
}

def theoremPlusZero: ∀(n: ℕ) -> (n + o === n) = {
    ((n: ℕ) => ℕ.Eq(n + o, n)).induction(
        ℕ.refl(ℕ::Zero),
        (n: ℕ, assumption: (n + o === n)) => {
            inductionReduce(
                n, n + o, assumption,
                (n': ℕ) => (n'.succ === n.succ),
                ℕ.refl(n.succ)
            )
        }
    )
}
